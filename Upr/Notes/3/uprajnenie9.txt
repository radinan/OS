winscp - инсталация...
hostname - atero.openfmi.net
username - s<fn>
password - <pw>
др не пипаме 
->connect
някакъв warning (ignore)
=> 2 части
лява  = наша ФС
дясна = remote ФС
---------------------------------------------
	-
~~| C |~~
	-
	
	
C - компилируем език
(source code => компилираме => изпълним файл)
					gcc

_______________
hello_world.c |
--------------|

#include <stdio.h> //за pritntf

int main() {
	pritntf("Hello world!\n");
	return 0;
}

компилиране:
gcc <code>
gcc hello_world.c 
=> създава се a.out
изпълняване:
./a.out 
(->вади Hello world!)

флагове за gcc:
-o 		- сменяме името на изпълнимия файл (a.out)
(gcc -o new_name hello_world.c)

-Werror - warning-ите да са третирани като error-и
-Wall (*)
-Wpedantic (*) - включват допълнителни warning-и
-pedantic			  
-Wextra (*)
	
(gcc -Wall -Wpedantic -Wextra hello_worlld.c)
waning-ите са нефатални (не са предпоставка за "некомпилиране")
	
=> Werror (ако има warning=>error=>кодът не се компилира)
	
В курса:
файл, който не се компилира с флаговете
-std=c99 	- задава стандарт за поведение (версия на c)
-Werror
-Wall
-Wpedantic
-Wextra
-o 
=> грешен
	
	
За да не помним вс тези флагове => Makefile
make - може да чете make file-ове (в тях пише как да компилираме кода ни)
(fmi-os репо има го във вс зад)

make 
за да компилира файла:
В директорията, в която казваме make трябва:
1. да има make file
2. да има source code 
3. source code-а трябва да е в main.c	
	
	
----------------------------------------------------------------------------------
Памет и пойнтъри

файл - съвкупност от байтове
интерпретацията им зависи от програмата, която ги интерпретира

xxd - за стойностите на всеки байт във файла 



-------

unsigned short int - целочислен двубайтов integer
unsigned short int = 2B

в 2 байта -> 16 бита
[0, 2^16 - 1] = [0, 65355]

value = 2^15 * <bit value> + 2^14 * <bit value> + ... + 2^0 * <bit value>
<bit value> - 0 или 1

пример:
162 =  128
	    +
		32
		+
		2
2^7 + 2^5 + 2^1

Имаме 2-байтов integer 162 =>  

Byte A:
_________________
|0|0|0|0|0|0|0|0|
-----------------
няма нищо вдигнато

Byte B:
_________________
|1|0|1|0|0|0|1|0|
-----------------		
битовете са подредени от най-значещ към най-незначещ
(най-висока степен на 2ка към най-ниска)
=> вдигнати са битове за 7, 5, 1 степен на 2ката 


Byte A -  15-8
Byte B -   7-0

Endianess - показва как са подредени байтовете
			(първо най-ниските/най-високите)

Big Endianess
	AB
	
Little Endianess
	BA


-------

unsigned int - целочислен четирибайтов integer
unsigned int - 4B

в 4 байта -> 32 бита
[0, 2^32 - 1]

value = 2^31 * <bit value> + 2^30 * <bit value> + ... + 2^0 * <bit value>
<bit value> - 0 или 1

БИТОВЕТЕ ВИНАГИ от най-значещ -> най-незначещ
endianess - подредба на байтовете!

Little endianess (малко много)

1: 
_________________
|7| | | | | | |0|
-----------------
2: 
__________________
|15| | | | | | |8|
------------------
3: 
___________________
|23| | | | | | |16|
-------------------
4: 
___________________
|31| | | | | | |24|
-------------------


Big endianess (много малко)

1: 
___________________ 
|31| | | | | | |24|
-------------------
2: 
___________________ 
|23| | | | | | |16|
-------------------
3: 
__________________
|15| | | | | | |8|
------------------
4:
_________________
|7| | | | | | |0|
-----------------

-------
char* - null terminated string-ове 
в C няма тип "string"
има char*

2 въпроса:
1. къде в паметта е началото
2. къде в паметта е краят

2 подхода:
1. стрингове = структура с: ptr към началото; големина на стринга
2. ptr към началото; четем до "спец байт" = край
	=> не знаем големината, но знаем края 

-----
Типове памет:

1. Статична	- ясно е колко е (по време на компилация)
			- не зависи от изпълнението на процеса
			
2. Динамична - не е ясно колко ще трябва (по време на компилация)
			 
			 


----------------------------------------
man страници 

man man:
	коя секция за какво отговаря
(инт ни 2 и 3 секция)
2	- инф за вс system calls
				(OS dependent)
				!= за windows и linux
				
3	- инф за вс library calls
				(portable)
				== за вс ОС

имаме неразбираема ф-я 
=> system call 	-> man 2 <name>
=> library call -> man 3 <name>


в man 3 стр:
NAME
	имена_на_функции
SYNOPSIS
	#include <header file>
	....
	signatures_на_функциите
	....
...
	
-------------------------------------------------------
System/Library calls
(да се прочетат man страниците :) жизненоважно е)
ВИНАГИ обработка на случая, ако sys call-а fail-не

|~~~~~~|
|malloc| колко byte-а памет искаме от ОС да задели
|~~~~~~|

void *malloc(size_t size)

успех 	-> ptr към началото (линейно подредени)
неуспех -> null

ПРЕДИ края => винаги деалокиране (освобождаване на паметта)
иначе - memory leak 

|~~~~|
|free| освобождава алокираната памет
|~~~~|

void free(void *ptr)

|~~~~|
|exit| връща exit status
|~~~~|

#include <stdlib.h>
exit(<status>);
exit(5);

Винаги при промяна в сорс кода
=>прекомпилация

Ако не сме Include-нали библиотеката
=> като изп команда make
=> error "implicit declaration of function '...'"
=> ако го няма => man 3 ... => виждаме header-a :)

SC:

|~~~~|
|open| позволява да работим с файлове
|~~~~|

#include <sys/type.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char*pathname, int flags)
успешно   ->num of file descriptor
неуспешно -> -1

file descriptor - стр-ра, която ОС използва, за да репрезентира файлове
(уникални за процес)

важни флагове:
O_RDONLY - read only
O_WRONLY - write only
O_RDWR	 - read & write

O_APPEND   - за писане -> добавяне към края 
O_TRUNCATE - ако файлът съществуа -> трие се
O_CREATE   - ако не съществува, се създава файлът
			(O_create и 3 аргумент за perms)
			
алокирали сме памет за ФД
=> да я деалокираме
	
|~~~~~|
|close| деалокиране на ФД
|~~~~~|

#include <unistd.h>

int close(int fd);
успех   -> 0
неуспех -> -1

ФД имат позиция, която показва къде се намираме във файла
четем 5 байта
не сме правили нищо -> 0-4 байт
четем 10 байта
					-> 5-14байт

|~~~~|
|read| четем от файл
|~~~~|

#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);

<fd>  	- (от) ФД = файл за четене
<buf> 	- (към) парче памет, в което записваме прочетеното
<vount> - (колко) колко байта четем

успех   -> връща колко е успял да прочете
неуспех -> -1

|~~~~~|
|write| пишем във файл
|~~~~~|

#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);

<fd>  	- (към) ФД = файл за писане
<buf> 	- (от) парче памет, от което четем
<vount> - (колко) колко байта пишем

успех   -> връща колко е успял да запише
неуспех -> -1


1:14:58





