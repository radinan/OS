------
| #a |
------
1. Сортирайте /etc/passwd лексикографски по поле UserID.
(a0200)
cut -d : -f 1 /etc/passwd | sort

2. Сортирайте /etc/passwd числово по поле UserID.
(Открийте разликите с лексикографската сортировка)
(a0201)
cut -d : -f 1 /etc/passwd | sort -n

3. Изведете само 1-ва и 5-та колона на файла /etc/passwd спрямо разделител ":".
(a0210)
cut -d : -f 1,5 /etc/passwd --output-delimiter=' '


4. Изведете съдържанието на файла /etc/passwd от 2-ри до 6-ти символ.
(a0211)
 cut -c 2-6 /etc/passwd


5. Отпечатайте потребителските имена и техните home директории от /etc/passwd.
(a0212)
cut -d : -f 1,6 /etc/passwd --output-delimiter=' '


6. Отпечатайте втората колона на /etc/passwd, разделена спрямо символ '/'.
(a0213)
cut -d / -f 2 /etc/passwd


7. Изведете броя на байтовете в /etc/passwd.
Изведете броя на символите в /etc/passwd.
Изведете броя на редовете  в /etc/passwd.
(a1500)
wc -c /etc/passwd | cut -d ' ' -f 1
wc -m /etc/passwd | cut -d ' ' -f 1
wc -l /etc/passwd | cut -d ' ' -f 1


8. С отделни команди, извадете от файл /etc/passwd:
- първите 12 реда
- първите 26 символа
- всички редове, освен последните 4
- последните 17 реда
- 151-я ред (или друг произволен, ако нямате достатъчно редове)
- последните 4 символа от 13-ти ред (символът за нов ред не е част от реда)
(a2000)
head -n 12 /etc/passwd
head -c 26 /etc/passwd
head -n -4 /etc/passwd
tail -n 17 /etc/passwd
head -n 151 /etc/passwd | tail -n 1
head -n 13 /etc/passwd | tail -n 1 | tail -c 5
(????????????????????????????????????????????)


9. Запаметете във файл в своята home директория резултатът от командата `df -P`.
Напишете команда, която извежда на екрана съдържанието на този файл, без първия ред (хедъра), сортирано по второ поле (numeric).
(a3000)
df -P 1> ~/dfp.txt
tail -n +2 dfp.txt | sort -k2 -n


10. Запазете само потребителските имена от /etc/passwd във файл users във вашата home директория.
(a3100)
cut -d : -f 1 /etc/passwd 1> ~/users


11. Изпишете всички usernames от /etc/passwd с главни букви.
(a3500)
cat users | tr a-z A-Z


12.   Изведете реда от /etc/passwd, на който има информация за вашия потребител.
Изведедете този ред и двата реда преди него.
Изведете този ред, двата преди него, и трите след него.
Изведете *само* реда, който се намира 2 реда преди реда, съдържащ информация за вашия потребител.
(a5000)
grep s71957* /etc/passwd
grep -B 2 s71957* /etc/passwd
grep -B 2 -A 3 s71957* /etc/passwd
grep -B 2 s71957* /etc/passwd | head -n 1


13. Изведете колко потребители не изпозват /bin/bash за login shell според /etc/passwd
(hint: 'man 5 passwd' за информация какъв е форматът на /etc/passwd)
(a5001)
grep -v :*/bin/bash$ /etc/passwd | wc -l
(това потребители ли са??)

14. Изведете само имената на хората с второ име по-дълго от 6 (>6) символа според /etc/passwd
(a5002)
awk -F '[: ,]'  '{ if(length($6)/2 > 6) print $5 " " $6}' /etc/passwd
(при Unicode 6 символа са с дължина 12)

15. Изведете имената на хората с второ име по-късо от 8 (<=7) символа според /etc/passwd // !(>7) = ?
(a5003)
awk -F '[: ,]'  '{ if(length($6)/2 <= 7) print $5 " " $6}' /etc/passwd
awk -F '[: ,]'  '{ if(!(length($6)/2 > 7)) print $5 " " $6}' /etc/passwd

16. Изведете целите редове от /etc/passwd за хората от 03-a-5003
(a5004)
awk -F '[: ,]'  '{ if(length($6)/2 <= 7) print $0}' /etc/passwd

------
| #b |
------
17. Намерете само Group ID-то си от файлa /etc/passwd.
(b0300)
awk -F '[:,]' '/Радина Нунева/{print $4}' /etc/passwd

18. Колко коментара има във файла /etc/services ? Коментарите се маркират със символа #, след който всеки символ на реда се счита за коментар.
(b3400)
awk -F '[:,]' '/^#/{++i} END{print +i}' /etc/passwd

??19.?? Колко файлове в /bin са 'shell script'-oве? (Колко файлове в дадена директория са ASCII text?)
(b3500)
find /etc -name '*.sh'
??????????????????????????????????????????????????????????????????????????????????????????????????

??20.?? Направете списък с директориите на вашата файлова система, до които нямате достъп. Понеже файловата система може да е много голяма, търсете до 3 нива на дълбочина.
(b3600)
??????????????????????????????????????????????????????????????????????????????????????????????????

21. Създайте следната файлова йерархия в home директорията ви:
dir5/file1
dir5/file2
dir5/file3

Посредством vi въведете следното съдържание:
file1:
1
2
3

file2:
s
a
d
f

file3:
3
2
1
45
42
14
1
52

Изведете на екрана:
	* статистика за броя редове, думи и символи за всеки един файл
	* статистика за броя редове и символи за всички файлове
	* общия брой редове на трите файла
(b4000)
mkdir ~/dir5
touch ~/dir5/file1
touch ~/dir5/file2
touch ~/dir5/file3

vi file1 (i -> ... -> esc -> :wq)
vi file2
vi file3

wc -lwm file1 file2 file3 && wc -l file1 file2 file3 | tail -n +4


22. Във file2 (inplace) подменете всички малки букви с главни.
(b4001)
sed -i 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' file2
или
sed -i 's/\([a-z]*\)/\U\1/' file2


23. Във file3 (inplace) изтрийте всички "1"-ци.
(b4002)
sed -i 's/1//g' file3


24. Изведете статистика за най-често срещаните символи в трите файла.
(b4003)
->1. вс. символ на нов ред
->2. сортиране
->3. юник -c 
->4. сортиране
->5. само първите n (може и без това)
->6. форматиране

cat file1 file2 file3 | sed 's/\(.\)/\1\n/g' | sort | uniq -c |tail -n +2 | sort -r | head -n 5 | awk '{print $1 " times symbol " $2}'


25. Направете нов файл с име по ваш избор, чието съдържание е конкатенирани
съдържанията на file{1,2,3}.
(b4004)
cat file1 file2 file3 >> file4


26. Прочетете текстов файл file1 и направете всички главни букви малки като
запишете резултата във file2.
(b4005)
cat file1 && sed 's/\([A-Z]*\)/\L\1/' file1 >file2
cat file2 && sed 's/\([A-Z]*\)/\L\1/' file2 >file1 (или по-скоро така)

27. Намерете броя на символите, различни от буквата 'а' във файла /etc/passwd
(b5200)
-> 1. вс символ на нов ред
-> 2. вс символ = а се трие
-> 3. юник -с 
-> 4. форматиране

sed 's/\([a*]\)//g' /etc/passwd | sed 's/\(.\)/\1\n/g' | sort | uniq -c |  awk 'BEGIN {i=0;} {i+=$1;} END {print i;}'



??28. ??Намерете броя на ???уникалните символи???, използвани в имената на потребителите от /etc/passwd.
(b5300)
???????????????????????????????????????????????????????????????????????????????????????????????

29. Отпечатайте всички редове на файла /etc/passwd, които не съдържат символния низ 'ов'.
(b5400)
awk '!/.ов./{print $0}' /etc/passwd


30. Отпечатайте последната цифра на UID на всички редове между 28-ми и 46-ред в /etc/passwd.
(b6100)
-> 1. 1-46 ред 
-> 2. 28-46 ред 
-> 3. 3 колонка
-> 4. последна цифра

head -n 46 /etc/passwd | tail -n +28 | cut -d : -f 3 | sed 's/.*\(.$\)/\1/'


31. Отпечатайте правата (permissions) и имената на всички файлове, до които имате
read достъп, намиращи се в директорията /tmp. (hint: 'man find', вижте -readable)
(b6700)
find /tmp -readable 2> /dev/null | ls -l | awk '{print $1 " " $9}'


32. Намерете имената на 10-те файла във вашата home директория, чието съдържание е
редактирано най-скоро. На първо място трябва да бъде най-скоро редактираният
файл. Намерете 10-те най-скоро достъпени файлове. (hint: Unix time)
(b6900)
ls -lt ~ | awk '{print $9}' |  head -n 11 | tail -n 10
ls -lu ~ | awk '{print $9}' |  head -n 11 | tail -n 10
ls -l --time=atime ~ | awk '{print $9}' |  head -n 11 | tail -n 10


33. да приемем, че файловете, които съдържат C код, завършват на `.c` или `.h`.
Колко на брой са те в директорията `/usr/include`?
Колко реда C код има в тези файлове?
(b7000)
find /usr/include/ -maxdepth 1 -name "*.h" -o -name "*.c" | wc -l
find /usr/include/ -maxdepth 1 -name "*.h" -o -name "*.c" | xargs -I {} wc -l {} | awk 'BEGIN{i=0} {i+=$1} END{print i}'


34. Даден ви е ASCII текстов файл - /etc/services. Отпечатайте хистограма на 10-те най-често срещани думи.
Дума наричаме непразна последователност от букви. Не правим разлика между главни и малки букви.
Хистограма наричаме поредица от редове, всеки от които има вида:
<брой срещания> <какво се среща толкова пъти>
(b7500)
(приемаме, че в 8140/tcp, tcp е валидна дума)
-> 1. (махаме небукви) вс дума на нов ред (махаме празни редове)
-> 2. сорт 
-> 3. юник 
-> 4. сорт по числата
-> 5. tail на 10те (ако тр да се разменят колоните с awk)

sed 's/[^a-zA-Z]/ /g' /etc/services | sed 's/ /\n/g' | sed '/^$/d' | sort  | uniq -c | sort -n | tail -n 10


?35. Вземете факултетните номера на студентите (описани във файла /srv/os/mypasswd.txt) от СИ и ги запишете във файл si.txt сортирани.
Студент е част от СИ, ако home директорията на този потребител (според /srv/os/mypasswd.txt) се намира
в /home/SI директорията.
(b8000)
-> 1. колконки по [:] => 6 колона - колонки по [/] => 2 колона == SI => принт 
-> 2. колконки по [:] => 1 колона => sed маха буквата s 
-> 3. sort 
-> 4. pipe към si.txt 

awk -F '[:/]' '{if($8 == "SI") print $0}' /srv/os/mypasswd.txt
| awk -F ':' '{print $1}' | sed 's/[a-zA-Z]//g' | sort -n | sed '/^$/d' 1> si.txt
(mai raboti)


36. За всяка група от /etc/group изпишете "Hello, <група>", като ако това е вашата група, напишете "Hello, <група> - I am here!".
(b8500)
awk -F ':' 'BEGIN{id='$(id -g s71957)'} {if(id==$3)print "Hello, " $0 " - I am here!"; else print "Hello, " $0;}' /etc/group


37. Shell Script-овете са файлове, които по конвенция имат разширение .sh. Всеки
такъв файл започва с "#!<interpreter>" , където <interpreter> указва на
операционната система какъв интерпретатор да пусне (пр: "#!/bin/bash",
"#!/usr/bin/python3 -u").

Намерете всички .sh файлове в директорията `/usr` и нейните поддиректории, и
проверете кой е най-често използваният интерпретатор.
(b8600)

find /usr -name '*.sh' | xargs -I {} head -n 1 {} | sed -e 's/^[^#]*//g' -e 's/[[:space:]]//g' -e '/^$/d' | 
sort | uniq -c | sort -rn | head -n 1 | awk '{print $2}'


38. 1. Изведете GID-овете на 5-те най-големи групи спрямо броя потребители, за които
	съответната група е основна (primary).
	2. (*) Изведете имената на съответните групи.
	Hint: /etc/passwd
(b8700)

awk -F ':' '{print $4}' /etc/passwd | sort | uniq -c | sort -rn| head -n 5 | awk '{print $2}'

awk -F ':' '{print $4}' /etc/passwd | sort | uniq -c | sort -rn| head -n 5 | awk '{print $2}' | 
xargs -I {} grep :{}: /etc/group | awk -F ':' '{print $1}'


??39.?? Направете файл eternity. Намерете всички файлове, намиращи се във вашата home
директория и нейните поддиректории, които са били модифицирани в последните
15мин (по възможност изключете .).  Запишете във eternity името (път) на
файла и времето (unix time) на последната промяна.
(b9000)
???????????????????????????????????????????????????????????????????????????????????

40. Копирайте файл /srv/os/population.csv във вашата home директория.
(b9050)
:P

41.   Използвайки файл population.csv, намерете колко е общото население на света
през 2008 година. А през 2016?
(b9051)

cat population.csv | awk -F ',' '{if($3 == "2008") i+=$3} END{print i}'
(cat population.csv | awk -F ',' '{if($3 == "2008") print $0}' | awk -F ',' '{i+=$3} END{print i}')

cat population.csv | awk -F ',' '{if($3 == "2016") i+=$3} END{print i}'


42. Използвайки файл population.csv, намерете през коя година в България има най-много население.
(b9052)

cat population.csv | awk -F ',' '{if($1 == "Bulgaria") print $0}' | sort -t ',' -k 4 -rn | head -n 1 | awk -F ',' '{print $3}'

43. Използвайки файл population.csv, намерете коя държава има най-много население през 2016. А коя е с най-малко население?
(Hint: Погледнете имената на държавите)
(b9053)

cat population.csv | awk -F ',' '{if($3 == "2016") print $0}' | sort -t ',' -k 4 -rn | head -n 1

cat population.csv | awk -F ',' '{if($3 == "2016") print $0}' | sort -t ',' -k 4 -rn | tail -n 1


44. Използвайки файл population.csv, намерете коя държава е на 42-ро място по население през 1969. Колко е населението й през тази година?
(b9054)

cat population.csv | awk -F ',' '{if($3 == "1969") print $0}' | sort -t ',' -k 4 -rn | head -n 42 | tail -n 1 | awk -F ',' '{print $4}'


45. В home директорията си изпълнете командата `curl -o songs.tar.gz "http://fangorn.uni-sofia.bg/misc/songs.tar.gz"`
(b9100)

46. Да се разархивира архивът songs.tar.gz в папка songs във вашата home директорията.
(b9101)

47. Да се изведат само имената на песните.
(b9102)

48. Имената на песните да се направят с малки букви, да се заменят спейсовете с долни черти и да се сортират.
(b9103)

49. Да се изведат всички албуми, сортирани по година.
(b9104)

50. Да се преброят/изведат само песните на Beatles и Pink.
(b9105)

51. Да се направят директории с имената на уникалните групи. За улеснение, имената от две думи да се напишат слято:
Beatles, PinkFloyd, Madness
(b9106)

52. Напишете серия от команди, които извеждат детайли за файловете и директориите в
текущата директория, които имат същите права за достъп както най-големият файл
в /etc директорията.
(b9200)

53. Дадени са ви 2 списъка с email адреси - първият има 12 валидни адреса, а вторията има само невалидни. Филтрирайте всички адреси, така че да останат само валидните. Колко кратък регулярен израз можете да направите за целта?

Валидни email адреси (12 на брой):
email@example.com
firstname.lastname@example.com
email@subdomain.example.com
email@123.123.123.123
1234567890@example.com
email@example-one.com
_______@example.com
email@example.name
email@example.museum
email@example.co.jp
firstname-lastname@example.com
unusually.long.long.name@example.com

Невалидни email адреси:
#@%^%#$@#$@#.com
@example.com
myemail
Joe Smith <email@example.com>
email.example.com
email@example@example.com
.email@example.com
email.@example.com
email..email@example.com
email@-example.com
email@example..com
Abc..123@example.com
(),:;<>[\]@example.com
just"not"right@example.com
this\ is"really"not\allowed@example.com
(b9300)















